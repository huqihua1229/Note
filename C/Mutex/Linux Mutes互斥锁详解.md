实现多线程同步的常用方法有 4 种，分别称为互斥锁、信号量、条件变量和读写锁，互斥锁是其中最简单也最有效地的方法

互斥锁实现多线程同步的核心思想是：有线程访问进程空间中的公共资源时，该线程执行“加锁”操作（将资源“锁”起来），阻止其它线程访问。访问完成后，该线程负责完成“解锁”操作，将资源让给其它线程。当有多个线程想访问资源时，谁最先完成“加锁”操作，谁就最先访问资源。

> 当有多个线程想访问“加锁”状态下的公共资源时，它们只能等待资源“解锁”，所有线程会排成一个等待（阻塞）队列。资源解锁后，操作系统会唤醒等待队列中的所有线程，第一个访问资源的线程会率先将资源“锁”起来，其它线程则继续等待。

本质上，互斥锁就是一个全局变量，它只有 "lock" 和 "unlock" 两个值，含义分别是：

- "unlock" 表示当前资源可以访问，第一个访问资源的线程负责将互斥锁的值改为 "lock"，访问完成后再重置为“unlock”；
- "lock" 表示有线程正在访问资源，其它线程需等待互斥锁的值为 "unlock" 后才能开始访问。

通过对资源进行 "加锁（lock）"和 "解锁（unlock）"，可以确保同一时刻最多有 1 个线程访问该资源，从根本上避免了“多线程抢夺资源”的情况发生。

再次强调，对资源进行“加锁”和“解锁”操作的必须是同一个线程。换句话说，哪个线程对资源执行了“加锁”操作，那么“解锁”操作也必须由该线程负责。

POSIX 标准规定，用 pthread_mutex_t 类型的变量来表示一个互斥锁，该类型以结构体的形式定义在`<pthread.h>`头文件中。

```c
#include <pthreadtypes.h>
typedef union
{
    struct __pthread_mutex_s __data; // __pthread_mutex_s 定义在 struct_mutex.h 中
    char __size[__SIZEOF_PTHREAD_MUTEX_T];
    long int __align;
}pthread_mutex_t;
```
