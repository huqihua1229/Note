[const修饰指针的三种效果，C语言const修饰指针详解](http://c.biancheng.net/view/218.html)

https://zhuanlan.zhihu.com/p/89817219

https://www.zhihu.com/question/37608201

# const 修饰指针

## const int *p  = &a

这种情况下 const 和 int 的位置可以互换，二者是等价的。

当把 const 放在最前面的时候，修饰的是 *p，那么 *p 就是不可变的。

*p 表示的是指针变量 p 指向的内存单元中存放的内容，此时这个内容是不可变的。

其他的都可变，如 p 中存放的是指向内存单元的地址，这个地址是可以改变的，即 p 的指向可以改变。但指向谁，谁的内容就不可变。

这种用法常见于定义函数的形参。通过函数传递参数时，就把数据暴露了。而大多数情况下只是想使用传过来的数据，并不像改变它的值，但往往由于编程人员个人水平的原因会不小心改变它的值。此时在形参中用 const 把传过来的数据定义为只读的，这样就更安全了。

如果不想改变某个参数传过来的值，那么定义函数时最好用 const 修饰这个参数，否则就不要用 const 修饰。

## int * const p = &a

此时 const 修饰的是 p，所以 p 中存放的内存单元的地址不可变，而内存单元中的内容可变。即 p 的指向不可变，p 所指向的内存单元的内容是可变的。

## const int * const p = &a

此时 *p 和 p 都被修饰了，那么 p 中存放的内存单元的地址和内存单元中的内容都sdasdasd不可变。

综上所述，使用 const 可以保护用指针访问内存时由指针导致的被访问内存空间中数据的误更改。因为指针是直接访问内存的，没有拷贝，而有些时候使用指针访问内存时并不是要改变里面的值，而只是要使用里面的值，所以一旦不小心误操作把里面的数据改了就糟糕了。  

但是这里需要注意的是，上面第 1 种情况中，虽然在 *p 前加上 const 可以禁止指针变量 p 修改变量 a 中的值，但是它只能“禁止指针变量 p 修改”。也就是说，它只能保证在使用指针变量 p 时，p 不能修改 a 中的值。但是我并没有说 const 可以保护 a 禁止一切的修改，其他指向 a 的没有用 const 修饰的指针变量照样可以修改 a 的值，而且变量 a 自己也可以修改自己的值。
